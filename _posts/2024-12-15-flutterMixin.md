---
layout: post
title:  "Flutter Mixin 详解"
author: "daweibayu"
tags: Flutter
excerpt_separator: <!--more-->
---

<!--more-->

Dart 不支持多继承，但通过 mixin 可以混入多个类的行为。mixin 是一种特殊的类，用于将功能注入到其他类中。


一个类可以混入多个 mixin：
使用 on 关键字限制 mixin 只能被指定类型的类混入。


多继承替代方案：Mixin


3. Mixin 和继承的区别
	•	继承 是 “is-a” 关系：子类继承父类的所有成员，且子类可以覆盖父类的方法。
	•	Mixin 是 “has-a” 或 “can-do” 关系：类通过混入 mixin 来获得额外的功能，而不影响类的主继承链。



类似 kotlin 的扩展函数，都是`裱糊匠`，但确实好用


## 限制

mixin 是通过代码注入的方式实现的，所以其实主要还是在编译时起作用，而非运行时。也因此会有一定的限制。

比如：
1. mixin 本身不能被实例化
2. mixin 不能继承，但可实现。这就意味着 mixin 本身不会被真实的`类化`，只是使用了类的形式




## 实现机制


mixin 的实现机制
	1.	代码注入（行为复用）
	•	在使用 mixin 时，mixin 定义的所有方法和属性会被注入到使用它的类中。这个过程类似于拷贝 mixin 的方法和属性到目标类，但实际在运行时，Dart 编译器会优化这一过程。
	2.	单继承链保持完整
	•	mixin 并不改变 Dart 的单继承模型。一个类仍然只能通过 extends 继承一个父类，mixin 提供的功能是注入到继承链中而不破坏主继承链的结构。
	3.	动态分发机制
	•	在运行时，当一个方法被调用时，Dart 会根据对象的继承链和 mixin 的使用顺序动态查找方法实现，这种动态分发确保了混入的功能被正确调用。





## 横向对比

### kotlin 扩展函数



1. 核心概念对比

特性	Dart 的 mixin	Kotlin 的扩展函数
本质	一种功能复用机制，通过 with 将方法和属性注入到目标类。	一种静态方法绑定机制，通过扩展现有类添加新功能，而无需修改其源码。
修改类本身	实际修改了目标类，mixin 的方法和属性会被注入到类中，成为类的一部分。	不修改类本身，扩展函数只是外部定义的静态方法，实际调用时会被编译为静态方法。
是否支持状态	可以包含状态（字段），状态会被注入目标类。	不支持状态，只能定义无状态的方法。
调用方式	目标类直接调用 mixin 中的方法和属性，像调用普通类成员一样。	目标类对象通过“点操作符”调用扩展函数，但函数本质是静态方法。

2. 代码示例对比

Dart 的 mixin 示例

mixin Flyable {
  void fly() => print('I can fly');
}

mixin Swimmable {
  void swim() => print('I can swim');
}

class Bird with Flyable, Swimmable {}

void main() {
  Bird bird = Bird();
  bird.fly();  // 输出: I can fly
  bird.swim(); // 输出: I can swim
}

	•	行为： Flyable 和 Swimmable 的方法被注入到 Bird 类，Bird 实例直接调用这些方法。
	•	状态： 如果 Flyable 中定义了属性（如 speed），这些属性也会被注入。

Kotlin 的扩展函数示例

fun String.shout(): String = this.uppercase() + "!"

fun main() {
    val message = "hello"
    println(message.shout()) // 输出: HELLO!
}

	•	行为： shout 是扩展函数，但并未修改 String 类本身，message.shout() 本质是一个静态方法调用。
	•	状态： 不能为 String 类添加属性。

3. 适用场景的对比

场景	Dart 的 mixin	Kotlin 的扩展函数
功能复用（多继承替代）	可用来实现多行为复用，弥补 Dart 单继承的限制。	不适合实现多继承功能，仅提供方法扩展。
动态添加方法	将 mixin 混入类中，相当于动态添加方法和属性。	仅适合为已有类静态添加无状态的方法，而不支持动态修改类定义。
依赖特定父类	可以通过 on 限制 mixin 的适用范围（依赖于某个基类）。	无法依赖任何父类，只能扩展现有类的公开 API。
静态扩展现有类	不适合，仅适合功能注入，不是扩展现有类的方法。	专为扩展现有类的功能设计，尤其是无法修改类源码的情况下。

4. 优缺点的对比

特性	Dart 的 mixin	Kotlin 的扩展函数
优点	- 支持多行为复用，适合复杂功能组合。	- 简单直接，可为现有类添加方法，无需修改类源码。
	- 可以包含状态（字段）。	- 不依赖继承，保持类的单一职责。
缺点	- 引入了状态可能导致复杂度增加。	- 不能扩展状态，只能定义无状态的方法。
	- 增加了目标类的代码体积。	- 扩展函数调用效率略低（底层是静态函数调用）。

5. 深入实现机制的对比

实现机制	Dart 的 mixin	Kotlin 的扩展函数
编译原理	mixin 的方法和属性在编译时会注入到目标类中，目标类直接持有这些成员。	扩展函数编译为静态方法，调用时目标类对象作为静态方法的第一个参数（类似 this）。
运行时行为	在运行时，目标类的实例可以直接访问 mixin 注入的方法和属性。	扩展函数只存在于调用的上下文，不会修改运行时对象结构。
依赖	可以依赖目标类提供特定方法（通过 on 关键字实现限制）。	无法依赖目标类的具体实现，只能使用目标类的公开 API。

总结：Dart mixin 与 Kotlin 扩展函数的异同

相同点
	1.	代码复用： 都是为了解决代码复用问题，减少重复逻辑。
	2.	不破坏类定义： 都避免直接修改目标类（mixin 通过组合，扩展函数通过静态方法）。

不同点

特性	Dart 的 mixin	Kotlin 的扩展函数
功能目标	解决多继承的需求，支持状态和行为复用。	为现有类添加方法扩展，尤其在无法修改类源码时使用。
状态支持	支持注入状态（字段）。	不支持状态扩展，只能定义无状态的方法。
依赖机制	可通过 on 关键字限制适用范围，依赖特定父类或接口。	无法限制，适用于所有可见的目标类。
运行机制	注入目标类，方法成为类的一部分。	编译为静态方法，目标类对象作为静态方法的第一个参数。

推荐使用场景
	•	Dart 的 mixin： 当需要多行为复用、状态共享，或者需要依赖父类功能时。
	•	Kotlin 的扩展函数： 当需要为现有类添加无状态方法，而不希望破坏类定义时。


### C++ 多继承


