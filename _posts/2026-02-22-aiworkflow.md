---
layout: post
title:  "AI 工作流最佳实践"
author: "daweibayu"
tags: AI
excerpt_separator: <!--more-->
---

 <!--more-->

## AI 工作流最佳实践

## 0. 方法论

- **执行流（Default Loop）**：边界/契约（写入源文档）→ 执行包（步骤 + 测试用例 + 验证计划，不含代码）→ 垂直切片（编码跑通端到端）→ 验证（产出证据）→ 反哺（证据结论写回源文档）。
- **分层产物**：源文档/执行包/代码。只允许“反哺写回源文档”；执行包需要版本管理（通常只管理其中一部分），其余细节不入库（可再生）。
- 由文档生成代码，人机交互的媒介从原来的代码变为文档（这也是“源文档”词的由来）
- 去除原有 PM/RD/QA/UI 等角色分类与原工作流，统一为 agent 工程师
- 将 PRD/UI/Case 等上下文纳入统一仓库，并 git 管理，人只负责管理上下文，具体执行交由 AI
- 进度规划与管理统一进 git 管理（并实时展示）
- 原则上人类主要重心为“源文档”部分；尽量少介入“执行包”部分；原则上不直接介入“代码”部分

## 1. 分层模型

### 1.1 源文档（SoT: Source of Truth）

定义：长期维护、可评审、用于“决策/约束/契约/模板/验收标准”的内容。

- **允许人工编辑**：是最终依据。  
- **进入版本库**：可追溯、可协作。
- **典型内容**：
  - 目标与计划：北极星、milestone/roadmap（含当前进度）
  - 需求与体验：产品需求文档（可从飞书单向同步到代码仓）、UI/UE 规范
  - 边界与约束：安全/隐私/合规/依赖/改动边界
  - 契约与规则：API/数据模型/错误模型/事件埋点/领域词典、代码/分支/commit 规范、rules
  - 架构与决策：业务架构、技术架构、ADR（关键取舍记录，需要固定模版）
  - 质量与验收：DoD/回归点/测试架构、验收标准与测试清单
  - 模版：模块目录模版、ADR 模版、EP 模版等

### 1.2 执行包（Execution Pack, EP）

定义：以一个功能为单位，把源文档 → 代码之间的细粒度执行细节独立出来（不含具体代码），用于落地与防漂移。

- **内容**：步骤清单（细到可编码粒度）、测试用例清单、验证计划与证据引用、回滚方案、依赖与风险（不含具体代码）。
- **上下文策略**：上下文权威留在源文档；执行包只做输入锁定（Input Lock：引用 + 版本/commit/revision）并保存执行所需摘要（Digest），不复制源文档全文。
- **版本管理与合规**：执行包需要版本管理（通常只管理其中一部分）；可再生/临时细节不入库

### 1.3 代码（Code）

定义：可运行/可发布的实现与测试。

- **进入版本库**：遵循项目架构与代码规范。
- **边界**：执行包输出测试用例清单与验收口径；自动化测试代码属于代码层。
- **代码生成的客观要求**：
  - 最小改动、复用现有逻辑、避免无关重构
  - 变更必须可验证（可运行/可测试/有证据）

---

## 2. 执行流

- 流程概览：边界/契约（源文档）→ 执行包 → 垂直切片（代码）→ 验证 → 反哺

### 2.1 边界（Guardrails）

归属：写入源文档；执行包只引用本功能相关条目。

目标：把“不可讨论/不可变更/不可触碰”的内容先固定，避免落地时漂移与返工。

边界至少包含 5 类（与业务无关）：

- **目标边界**：本阶段优化什么（速度/质量/成本/试错）？用什么衡量？
- **范围边界**：本阶段做什么/不做什么（非目标清单）。
- **系统边界**：已有系统是什么、明确没有什么；允许/禁止引入哪些依赖。
- **风险边界**：安全/隐私/合规/风控/内容治理红线（哪怕先写“暂不支持”）。
- **变更边界**：允许 AI 改哪里、禁止改哪里；每次改动的最大范围与回滚策略。

### 2.2 契约（Contracts）

归属：写入源文档；执行包只引用本功能涉及的契约点位（不复制全文）。

目标：把“团队/AI 必须一致理解”的内容写成可评审的契约，减少返工与扯皮。

- **工作流契约（Workflow Contracts）**：见 `.ai/conventions/WORKFLOW_CONTRACTS.md`。

最小契约集（建议从这 3 个开始）：

- **错误模型契约**：错误码、可重试/不可重试、用户提示口径、日志字段。
- **接口与数据契约**：API/本地存储/缓存策略/分页与幂等等约定。
- **事件埋点契约**：事件命名、属性、触发时机、口径（用于增长/留存/风控）。

### 2.3 执行包

归属：执行包入库并做版本管理（通常只管理其中一部分）

目标：把本功能的源文档输入锁定，并把落地所需细节（步骤/用例/验证/回滚）固化成可执行清单（不含代码），作为实现与验收的唯一执行依据。

- **输入锁定**：引用 + 版本/commit/revision（避免源文档实时变更导致漂移）
- **执行清单**：步骤清单（细到可编码粒度）
- **验收与测试**：测试用例清单 + 验收口径（测试代码在代码层）
- **验证与证据**：验证计划 + 证据引用位（产出后回填）
- **发布与回滚**：灰度/回滚方案、依赖与风险

### 2.4 垂直切片（Vertical Slice）

归属：代码层；以执行包为准落地。

目标：选一条最短可验收路径，从客户端到服务端（或 mock）到数据到埋点全链路跑通。

客观标准：一条路径至少满足

- 能“走完”（不依赖未实现模块）
- 能“观测”（关键埋点/日志齐全）
- 能“验证”（有测试或验收清单）
- 能“回滚”（失败可快速撤回）

### 2.5 验证（Verification）

归属：代码层产出证据；证据引用回填到执行包。

目标：让“完成”可被客观判断，而不是“感觉差不多”。

- **DoD（Definition of Done）**：本切片完成的客观标准（功能/质量/监控/文档）。
- **证据（Evidence）**：测试结果、性能基线、崩溃率、埋点数据、评审结论。

### 2.6 反哺（Feedback）

归属：写回源文档；执行包按需更新或重建（不做事实源）。

目标：把本次实现暴露的问题沉淀回源文档，使下一轮更快更稳。

- 反哺原则：**证据 → 结论 → 写回源文档**（不要把“猜测”写成事实）
- 典型反哺点：新增术语、更新契约、补充边界、记录 ADR、完善回归清单

---


## 3. TODO

- 熵增治理：SoT 会成为权力中心，而权力中心会产生瓶颈，SoT 的熵增会造成此流程不可持续
- GC 策略：删除行为本身是极高认知成本行为（人类非常不擅长删除文档），删除意味着承担风险，因此必须制度化，而不能依赖个人勇气
- 最小稳定单元（MSU），定义在多 EP 并行与频繁反哺条件下，能够提前锁定语义冲突的最小结构单元
- 文档的版本管理：SoT/EP 和部分文件的版本管理
- AI Native Context Operating System，上下文 Index 系统