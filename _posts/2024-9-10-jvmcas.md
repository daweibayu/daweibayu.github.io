---
layout: post
title:  "CAS 精谈"
author: "daweibayu"
tags: Android
excerpt_separator: <!--more-->
---

<!--more-->

本文先把代码从 java 到 native 全部列出，后续在补充内容。未完待续

```java
public class AtomicInteger extends Number implements java.io.Serializable {
    private static final long serialVersionUID = 6214790243416807050L;

    private static final sun.misc.Unsafe U = sun.misc.Unsafe.getUnsafe();
    private static final long VALUE;

    static {
        try {
            VALUE = U.objectFieldOffset
                (AtomicInteger.class.getDeclaredField("value"));
        } catch (ReflectiveOperationException e) {
            throw new Error(e);
        }
    }

    private volatile int value;

    ......

    /**
     * Atomically sets the value to the given updated value
     * if the current value {@code ==} the expected value.
     *
     * @param expect the expected value
     * @param update the new value
     * @return {@code true} if successful. False return indicates that
     * the actual value was not equal to the expected value.
     */
    public final boolean compareAndSet(int expect, int update) {
        return U.compareAndSwapInt(this, VALUE, expect, update);
    }

    ......
}
```
[Android12 - AtomicInteger.java](https://cs.android.com/android/platform/superproject/+/android12-platform-release:libcore/ojluni/src/main/java/java/util/concurrent/atomic/AtomicInteger.java)  
[Android 13 ](https://cs.android.com/android/platform/superproject/+/android13-release:libcore/ojluni/src/main/java/java/util/concurrent/atomic/AtomicInteger.java) 



[Unsafe.java](https://cs.android.com/android/platform/superproject/+/android14-release:libcore/ojluni/src/main/java/sun/misc/Unsafe.java)

```java
public final class Unsafe {
    /** Traditional dalvik name. */
    private static final Unsafe THE_ONE = new Unsafe();

    private static final Unsafe theUnsafe = THE_ONE;
    public static final int INVALID_FIELD_OFFSET   = -1;

    /**
     * This class is only privately instantiable.
     */
    private Unsafe() {}

    /**
     * Gets the unique instance of this class. This is only allowed in
     * very limited situations.
     */
    public static Unsafe getUnsafe() {
        Class<?> caller = Reflection.getCallerClass();
        /*
         * Only code on the bootclasspath is allowed to get at the
         * Unsafe instance.
         */
        ClassLoader calling = (caller == null) ? null : caller.getClassLoader();
        if ((calling != null) && (calling != Unsafe.class.getClassLoader())) {
            throw new SecurityException("Unsafe access denied");
        }

        return THE_ONE;
    }

    
    @FastNative
    public native boolean compareAndSwapInt(Object obj, long offset,
            int expectedValue, int newValue);

    
    @FastNative
    public native int getIntVolatile(Object obj, long offset);

    @FastNative
    public native void putIntVolatile(Object obj, long offset, int newValue);

    @FastNative
    public native int getInt(Object obj, long offset);

    @FastNative
    public native void putInt(Object obj, long offset, int newValue);

    @FastNative
    public native int getInt(long address);

    /**
     * Stores a {@code int} into the given memory address.
     *
     * @param address address in memory where to store the value
     * @param newValue the value to store
     */
    @FastNative
    public native void putInt(long address, int x);
}

```

[sun_misc_Unsafe.cc](https://cs.android.com/android/platform/superproject/+/android14-release:art/runtime/native/sun_misc_Unsafe.cc)

```c++
namespace art {

static jboolean Unsafe_compareAndSwapInt(JNIEnv* env, jobject, jobject javaObj, jlong offset,
                                         jint expectedValue, jint newValue) {
  ScopedFastNativeObjectAccess soa(env);
  ObjPtr<mirror::Object> obj = soa.Decode<mirror::Object>(javaObj);
  // JNI must use non transactional mode.
  bool success = obj->CasField32<false>(MemberOffset(offset),
                                        expectedValue,
                                        newValue,
                                        CASMode::kStrong,
                                        std::memory_order_seq_cst);
  return success ? JNI_TRUE : JNI_FALSE;
}
}
```


[object-readbarrier-inl.h - CasField32](https://cs.android.com/android/platform/superproject/+/android14-release:art/runtime/mirror/object-readbarrier-inl.h;l=41)


```
using AtomicInteger = Atomic<int32_t>;
```


[atomic.h - CompareAndSet](https://cs.android.com/android/platform/superproject/+/android14-release:art/libartbase/base/atomic.h;l=108)


```c++
  bool CompareAndSet(T expected_value,
                     T desired_value,
                     CASMode mode,
                     std::memory_order memory_order) {
    return mode == CASMode::kStrong
        ? this->compare_exchange_strong(expected_value, desired_value, memory_order)
        : this->compare_exchange_weak(expected_value, desired_value, memory_order);
  }
```


```c++
template <class _Tp>
_LIBCPP_HIDE_FROM_ABI
bool
atomic_compare_exchange_strong(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type* __e, typename atomic<_Tp>::value_type __d) _NOEXCEPT
{
    return __o->compare_exchange_strong(*__e, __d);
}
```



```c++
inline int32_t __sync_val_compare_and_swap(volatile int32_t* ptr, int32_t oldval, int32_t newval)
{
    int32_t ret = *ptr;
    (void)__sync_bool_compare_and_swap(ptr, oldval, newval);
    return ret;
}
```


atomics_arm.c

```c++
int
__atomic_cmpxchg(int old, int _new, volatile int *ptr)
{
    /* We must return 0 on success */
    return __sync_val_compare_and_swap(ptr, old, _new) != old;
}

int
__atomic_swap(int _new, volatile int *ptr)
{
    int prev;
    do {
        prev = *ptr;
    } while (__sync_val_compare_and_swap(ptr, prev, _new) != prev);
    return prev;
}
```


对于 arm64，compare_exchange_strong 会映射到硬件指令集的 ldxr/stxr。  
LDXR 属于 "Exclusive Load and Store" 指令集，结合 STXR 指令实现原子性操作。LDXR 负责从内存中的地址加载一个值，同时设置一个排他锁，确保其他处理器或内核不能修改这个内存位置，直到锁被释放。  
也就是，CAS 的实现最终其实仍然是通过“锁”来实现的，只不过并不是 jvm 和 C++ 程序中的锁来实现，而是硬件级别的锁来实现。